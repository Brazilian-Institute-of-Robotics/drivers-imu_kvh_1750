#include <fog_kvh_1750/KVH1750Parser.hpp>
#include <fog_kvh_1750/KVH1750Raw.hpp>
#include <endian.h>
#include <stdexcept>
#include <base/float.h>

#include <boost/lexical_cast.hpp>
#include <boost/crc.hpp>
#include <string>
using boost::lexical_cast;
using std::string;

using namespace fog_kvh_1750;

int KVH1750Parser::extractPacket(uint8_t const* buffer, size_t size, size_t max_size) const
{

    // Look for the first "thing" that looks like a valid header start
    size_t packet_start;
    for (packet_start = 0; packet_start < size; ++packet_start)
    {
        std::cout << "kvh parse cpp: check packet start byte vs ID : " << (int)buffer[packet_start] << " vs " << raw::Header::ID0 << std::endl;
        if (buffer[packet_start] == raw::Header::ID0)
	{
	    std::cout << "found header ID! - breaking for loop...\n";

         std::cout << "buffer at packet_start: " << (int)buffer[packet_start] << " " << (int)buffer[packet_start+1] << " " <<
         (int)buffer[packet_start+2] << " " <<(int)buffer[packet_start+3] << "\n";


            break;
	}
    }

    std::cout << "packet start = " << packet_start << " size = " << size;

    if (packet_start == size)
    {
        std::cout << " no packet start in buffer, discard everything";
        return -size;
    }
    else if (packet_start)
    {
       std::cout << " realign the IODriver buffer to the start of the candidate packet, returning -" << packet_start;
       return -packet_start;
    }
    else if (size > 1 && buffer[1] != raw::Header::ID1)
    {
        std::cout << " not actually a packet. Drop the first two bytes and let IODriver call us back";
        return -2; 
    }
    else if (size < sizeof(raw::Header))
    {
        std::cout <<" cannot parse the rest of the header yet ... wait for new data";
        return 0;
    }
 raw::Header const& header = *reinterpret_cast<raw::Header const*>(buffer);
    // This is the size EXCLUDING CHECKSUM
    uint16_t ensemble_size = 32; //le16toh(header.size);
    uint16_t total_size = ensemble_size + 4;
    if (max_size && max_size < total_size)
    {
        std::cout << "max_size " << max_size << " < " << " total_size " << total_size;

        // Assume that this packet is not valid as it has a size too big. Drop
        // the first two bytes, and let IODriver call us back to parse the rest
        // of the buffer
        return -2;
    }
    else if (size < total_size)
    {
        std::cout << "size " << size << " < " << " total_size " << total_size << ", wait for more data";
        // Have to wait for new data (we don't have a full packet yet)
        return 0;
    }

    uint16_t checksum = 0;
    std::cout << "packet elements:";
    for (int i = 0; i < ensemble_size +4; ++i)
    {  std::cout << " " << (int)buffer[i];
       checksum += buffer[i];
    }
    std::cout << std::endl;

   /* typedef boost::crc_optimal<32, 0x04C11DB7, 0xFFFFFFFF, 0x0, false, false>;
    crc_32_kvh_type;


    crc_32_kvh_type  result;

    result.process_bytes( buffer, ensemble_size );
    std::cout << "crc: " << result.checksum() << std::endl;

    // f5 e7 5b c3

    std::cout << "checksum = " << checksum;

    uint16_t msg_checksum = le16toh(*reinterpret_cast<uint16_t const*>(buffer + ensemble_size));

    std::cout << "msg checksum = " << msg_checksum;
*/

  /*  if (checksum != msg_checksum)
    {
        // Not a valid message. Drop the message IDs and let IODriver call us
        // back to find the start of the actual packet
        return -2;
    }
*/

/*   if (sizeof(raw::Header) + header.msg_count * 2 > ensemble_size)
        return -2;
    uint32_t offsets[256];
    for (int i = 0; i < header.msg_count; ++i)
        offsets[i] = le16toh(header.offsets[i]);

    // Validate sizes
    uint32_t expected_offset = 0;
    for (int i = 0; i < header.msg_count; ++i)
    {
        if (expected_offset != 0 && offsets[i] != expected_offset)
            return -2;

        uint32_t msg_id   = le16toh(*reinterpret_cast<uint16_t const*>(buffer + offsets[i]));
        uint32_t msg_size = getSizeOfMessage(msg_id);
        if (msg_size != 0)
            expected_offset = offsets[i] + msg_size;
    }*/
    std::cout << "returning total size = " << total_size;
    return total_size;
}

int KVH1750Parser::getSizeOfMessage(uint16_t msg_id) const
{
    return 0;
}

void KVH1750Parser::parseMessage(uint8_t const* buffer, size_t size)
{
    std::cout << "parseMessage with buffer " << (int)buffer[0] <<" "<< (int)buffer[1] << " ... " << (int)buffer[size-2] << " " << (int)buffer[size-1] << "\n";

    std::cout << "z accel bytes: " << (int)buffer[20] << " " <<(int)buffer[21] << " " <<(int)buffer[22] << " " <<(int)buffer[23] << "\n";

    int z_accel_int = buffer[23] | buffer[22] << 0x8 | buffer[21] << 0x10 | buffer[20] << 0x18;

    std::cout << "z_accel_int = " << z_accel_int << "\n";

    


//    uint16_t msg_id   = le16toh(*reinterpret_cast<uint16_t const*>(buffer));
//    switch(msg_id)
 //   {
/*    case raw::FixedLeader::ID:
        parseFixedLeader(buffer, size);
        if (cellReadings.readings.size() != acqConf.cell_count)
        {
            cellReadings.readings.resize(acqConf.cell_count);
            invalidateCellReadings();
        }
        break;
    case raw::VariableLeader::ID:
cout << "float value is: " << *(reinterpret_cast<float *>(&ulValue)) << endl;        parseVariableLeader(buffer, size);
        break;
    case raw::VelocityMessage::ID:
        cellReadings.time = status.time;
        parseVelocityReadings(buffer, size);
        break;
    case raw::CorrelationMessage::ID:
        cellReadings.time = status.time;
        parseCorrelationReadings(buffer, size);
        break;
    case raw::IntensityMessage::ID:
        cellReadings.time = status.time;
        parseIntensityReadings(buffer, size);
        break;
case raw::QualityMessage::ID:
        cellReadings.time = status.time;
        parseQualityReadings(buffer, size);
        break;
    case raw::BottomTrackingMessage::ID:
        bottomTracking.time = status.time;
        parseBottomTrackingReadings(buffer, size);
        break;*/
//    }
}

void KVH1750Parser::parseEnsemble(uint8_t const* buffer, size_t size)
{
    // Validate the message sizes
    raw::Header const& header = *reinterpret_cast<raw::Header const*>(buffer);
    

    std::cout << "parseEnsemble with buffer " <<  (int)buffer[0] << " " << (int)buffer[1] << " ... " <<
         (int)buffer[size-2] << " " <<(int)buffer[size-1] << "\n";


/*    if (sizeof(raw::Header) + header.msg_count * 2 > size)
        throw std::runtime_error("not enough bytes for " + lexical_cast<string>((int)header.msg_count) + " messages");

    uint32_t offsets[256];
    for (int i = 0; i < header.msg_count; ++i)
        offsets[i] = le16toh(header.offsets[i]);

    //invalidateCellReadings();
    for (int i = 0; i < header.msg_count; ++i)*/

    parseMessage(buffer + 4, size - 8);
}





